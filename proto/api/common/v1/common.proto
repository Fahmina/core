// The following is a list of messages that are used across multiple resource subtypes
syntax = "proto3";
option go_package = "go.viam.com/rdk/proto/api/common/v1";
option java_package = "com.viam.rdk.proto.api.common.v1";

package proto.api.common.v1;

message ResourceName {
  string uuid = 1;
  string namespace = 2;
  string type = 3;
  string subtype = 4;
  string name = 5;
}

message BoardStatus {
  map<string, AnalogStatus> analogs = 1;
  map<string, DigitalInterruptStatus> digital_interrupts = 2;
}

message AnalogStatus {
  // Current value of the analog reader of a robot's board 
  int32 value = 1;
}

message DigitalInterruptStatus {
  // Current value of the digital interrupt of a robot's board
  int64 value = 1;
}
/* Pose is a combination of location and orientation.
Location is expressed as distance which is represented by x , y, z coordinates. Orientation is expressed as an orientation vector which 
is represented by o_x, o_y, o_z and theta. The o_x, o_y, o_z coordinates represent the point on the cartesian unit sphere that the end of
the arm is pointing to (with the origin as reference). That unit vector forms an axis around which theta rotates. This means that 
incrementing / decrementing theta will perform an inline rotation of the end effector. Theta is defined as rotation between two planes: 
the first being defined by the origin, the point (0,0,1), and the rx, ry, rz point, and the second being defined by the origin, the rx, 
ry, rz point and the local Z axis. Therefore, if theta is kept at zero as the north/south pole is circled, the Roll will correct itself 
to remain in-line. */
message Pose {
  // millimeters from the origin
  double x = 1;
  // millimeters from the origin
  double y = 2;
  // millimeters from the origin
  double z = 3;
  // a vector, this input will get normalized to a point on the unit sphere
  double o_x = 4;
  // a vector, this input will get normalized to a point on the unit sphere
  double o_y = 5;
  // a vector, this input will get normalized to a point on the unit sphere
  double o_z = 6;
  // degrees
  double theta = 7;
}

message PoseInFrame {
  string reference_frame = 1;
  Pose pose = 2;
}

message Vector3 {
  double x = 1;
  double y = 2;
  double z = 3;
}

message Sphere {
  double radius_mm = 1;
}

message RectangularPrism {
  double width_mm = 1;
  double length_mm = 2;
  double depth_mm = 3;
}

message Geometry {
  common.v1.Pose center = 1;
  oneof geometry_type {
    Sphere sphere = 2;
    RectangularPrism box = 3;
  }
}

message GeometriesInFrame {
  string reference_frame = 1;
  repeated Geometry geometries = 2;
}

message PointCloudObject {
  // image frame expressed in bytes
  bytes point_cloud = 1;
  // volume of a given geometry
  common.v1.GeometriesInFrame geometries = 2;
}

message GeoPoint {
  double latitude = 1;
  double longitude = 2;
}

message Transform {
  // the name of a given reference frame
  string reference_frame = 1;
  // the pose of the above reference frame with respect
  // to a different observer reference frame
  PoseInFrame pose_in_observer_frame = 2;
}

message WorldState {
  repeated GeometriesInFrame obstacles = 1;
  // a list of Transforms needed to transform a pose
  // from one reference frame to another; this field is optional
  repeated Transform transforms = 2;
}
